{"name":"Cs6310p3","tagline":"GA Tech CS6310 Fall 14 Project 3, Team 22","body":"# CS6310P3\r\n========\r\n\r\n## GA Tech CS6310 Fall 14 Project 3, Team 22\r\n\r\n## CS6310 Project 3: Heated Planet\r\n\r\n### Background\r\n\r\nThis project uses the same application domain as the Heated Plate and Heated Earth projects but adds new functional and non-functional features. It asks you to prepare a simulation of the temperature of an arbitrary planet that includes a tilted axis and an elliptical orbit around its Sun. In addition, it includes the ability to persist simulation data. You will turn in your source code, a report describing its design and a separate report describing a design study of your program.\r\n\r\n### Persistence\r\n\r\nSimulation can be computationally costly. If a scientist needs to know a specific fact, such as the expected average temperature at the South Pole in the next century, and another scientist has already conducted a simulation study that answers the question, then it makes sense to use the existing result rather than to rerun the simulation. However, it must be the case that the existing simulation data satisfy all required scientific conditions.\r\n\r\nPersistence is a property of an application in which some of its data outlive the execution of the program that computed them. Persistence is often achieved by storing the data in some form of repository such as a database management system (DBMS), formatted documents (XML), or so-called flat files. Clients of this data can be the original application, other similar applications, a query interface provided by the DBMS or a newly written query interface program. In each case, input requests are analyzed to determine whether the required data are available for retrieval or if a simulation must be run.\r\n\r\nSimulators can run for long periods of time and generate large amounts of data. One of the design decisions that must be made in situations like this is how much data to save. In the case of the Heated Planet simulation, at one extreme is the saving of the temperature at every grid cell for every time period for all previously run simulations. At the other extreme is saving nothing and forcing a rerun for each request. The interesting situations are in between. That is, some values are saved, some are recomputed and others are computed by interpolating from saved values. For example, a geographically distributed sample of grid points might persist for all time periods, and requests for non-existent data could be satisfied by geographic interpolation. Alternatively, all grid points could be saved, but only for a sample of time periods. In this case, requests for missing data could be satisfied by temporal interpolation.\r\n\r\nUsing interpolation reduces output quality; that is, interpolated values may not provide as faithful a picture of the situation as would be obtained by redoing the simulation. Hence, one trade-off is between the amount of external storage used and the quality of the results obtained. Another trade-off is the classic time–space trade-off inherent when any data is stored rather than being recomputed.\r\n\r\n### Transparency\r\n\r\nA primary goal of the simulation system is, to the extent possible, to hide from the user whether requested data is being computed or retrieved. That is, the user interface should be constructed in such a way that the user requests certain data and the system determines whether it needs to perform a computation or can retrieve previously computed data. This kind of abstraction could be called data-source transparency. That is, the system should be transparent to the user with respect to the source of the data it returns.\r\n\r\nWhen the system is given a request, several issues arise. First, the simulation's Physical Factors (described below) may match those for a previously executed simulation. On the other hand, other details about the requested data (Simulation Settings, also described below) can be considered as approximations, allowing the system to interpolate from existing data. Another implication of data-source transparency is that the animated presentation of the data should work regardless of whether the data is computed or comes from stored data.\r\n\r\nMore details will be provided in the Graphical User Interface section below.\r\n\r\n### Simulating a Heated Planet\r\n\r\nThe Heated Planet simulation adds the following functional requirements to those used in Project 2.\r\n\r\nOrbit: In Project 2, it was assumed that the Earth was always the same distance from the Sun; that is, that it traversed a circular orbit. Actually the orbit of our planet is not quite circular; it is an ellipse with two axes of nearly equal lengths. Other planets have more eccentric orbits. If the lengths of the two axes of an ellipse are 2a and 2b, then the eccentricity of an ellipse is a non-negative number equal to sqrt(abs(difference(square(a),\r\n\tsquare(b))))/max(a, b). This will be a number greater than or equal to zero and strictly less than one. Your simulation for Project 3 should allow the eccentricity to be set by the user, with a default value of .0167, which is our Earth's eccentricity. Note that one implication of an eccentric orbit is that the amount of heat arriving at the planet from its Sun depends on the distance between them according to the inverse-squares law. Another is that the planet travels at different speeds during different parts of its orbit, thereby altering the number of daylight and nighttime hours.\r\nTilt: In Project 2, the axis of rotation of the Earth was perpendicular to its orbital plane. For the Earth, of course, the axis of rotation is tilted with respect to its orbit around the Sun. This is what causes the seasons. For example, on March 21st, the tilt or obliquity is perpendicular to the line between the center of the Earth and the Sun (i. e. the Sun is directly overhead at noon on the Equator). During the next three months, it gradually moves so that on June 21st, the Northern Hemisphere is pointed toward the Sun at an angle of 23.44°. This orbital motion has the effect of adjusting the vertical angle of incidence of each cell. For example, for a point on the Equator at noon on June 21st, the sunlight received is reduced to the cosine of 23.44° or 91% of its nominal value. Your simulation for Project 3 should allow the user to set the tilt to any value between ±180°, inclusive. The default should be +23.44°.\r\nAssumptions\r\n\r\n**The adjusted assumptions from Project 2 are listed here.**\r\n\r\n* The Sun is a point source with constant radiation output per unit of time.\r\n* The relative masses of the Sun and the planet are such that the elliptical orbit's focus, around which the planet's revolution takes place, can be approximated as the center of Sun.\r\n* There are no perturbations to the planet's orbit arising from other planets in the Solar System or from any moons.\r\n* At any given time, each point on the surface of the planet is the same distance from its Sun.\r\n* The orbital direction around the Sun is such that with the default values of tilt and eccentricity, summer will occur in the Northern Hemisphere between June 21st and September 21st.\r\n* Cooling of the planet is such that it exactly balances Solar heating for each time step.\r\n* The planet is spherical; there is no flattening at the Equator.\r\n* The axis of the planet does not wobble.\r\n* The planet's atmosphere plays no role, either in attenuating solar radiation or insulating against cooling loss. In general, there is no convective heating, only radiant (from the Sun) and conductive (from neighboring cells).\r\nNone of the radiation the planet receives from the Sun is reflected. Moreover, the heating effect of Solar radiation on the planet's surface is uniform. For example, there is no difference in the heating effect over desert, ice cap or water.\r\nThe size of a grid cell is small enough that it is uniformly heated by the Sun. That is, all points in a cell can be treated as being the same distance from the Sun and receiving radiation at the same angle.\r\nCartesian geometric computation are sufficiently accurate for this project. That is, you do not have to worry about spherical coordinates. In particular, each grid cell can be considered to be planar.\r\nGrid spacing in degrees is the same for both latitude and longitude. Longitude lines are parallel with the axis of rotation. Latitude lines are perpendicular to longitude lines. Consequently, each grid cell is a (possibly degenerate) trapezoid. Moreover, the angular spacing of grid cells divides evenly into 180°.\r\nAll grid cells cool in proportion to their current temperature and area, irrespective of their latitude.\r\nInitial Conditions\r\n\r\nThe start date of each simulation is January 4th with the planet at its closest point of approach (perihelion) to the Sun.\r\nOn each December 21st, the South Pole of the planet's axis is tilted toward the Sun.\r\nThe planet's rotation is such that the Sun is directly overhead (noon) at the Prime Meridian (longitude 0°). That will make the time midnight, January 4th at any position on the International Date Line (longitude 180°).\r\nThe temperature of all grid cells is 288° \r\n\r\nYou are to submit three deliverables—a software simulation system, a description of its design and a report of your design study.Kelvin.\r\nDeliverables\r\n\r\n## Program\r\n\r\n### Simulation Software\r\n\r\nYou should prepare software that provides the following features. (Note: please include with you source code a README.txt file containing the exact instructions for installing and running your program.)\r\n\r\nComputation of the temperatures at locations on the surface of a planet as it rotates about its axis and orbits the Sun\r\nGraphical user interface for controlling the simulation and enabling the setting of initial conditions\r\nFalse-color animation of the temperatures displayed on the planet's surface as it rotates and orbits\r\nQuery interface for retrieving computed values\r\nComputation\r\n\r\nYour system should be able to simulate the temperature of the planet as it rotates about its axis and orbits the Sun. The following Physical Factors affecting the computation should be included in the simulation model.\r\n\r\n* Axial tilt: integer degrees between ±180°; default is +23.44° (toward the Sun) in the Northern Hemisphere at the summer solstice.\r\n* Orbital eccentricity: non-negative real number less than one; default is .0167.\r\n* In addition to the above, the simulation to be performed depends on the following Simulation Settings.\r\n\r\n* Name: unique text string denoting the simulation.\r\n* Grid spacing: non-negative integer angle between 1° and 180°; default is 15° (one time zone). Only values that evenly divide 180° need to be accepted.\r\n* Simulation time step: non-negative integer minutes between 1 and 525,960 (1 Solar year), logarithmically graduated; default once per Solar day (1440 minutes). This value is not the length of the simulation nor is it the rate of presentation refresh; rather it controls the mapping from simulation steps to physical time units; that is, how much simulated time passes between temperature recalculations.\r\n* Simulation length: non-negative integer (Solar) months between 1 and 1200; default 12 (one Solar year).\r\nGraphical User Interface\r\n\r\nThe user should be able to interactively run the simulation using the following Controls.\r\n\r\n**Set the Physical Factors.**\r\n* Adjust the Simulation Settings.\r\n* Control the rate at which the presentation is displayed (which is different from the Simulation Time Step described above). This rate can be understand by using an analogy with time-lapse photography (TLP). In TLP pictures of a flower are taken every five minutes and shown one per second. The first number (five minutes) corresponds to the simulation time step; the second (one per second) corresponds to the presentation display rate.\r\n* Start the simulation running.\r\n* Pause the simulation.\r\n* Resume a paused simulation.\r\n* Stop the simulation or retrieval.\r\n* Determine whether the animation is displayed.\r\n* False-Color Animation\r\n\r\nWhen requested, the system should provide a graphical animation that includes the following aspects.\r\n\r\nFalse-color representation of the temperature in each grid cell (of the whole planet, not just the side facing the Sun)\r\nPoint on the planet's surface where the Sun is directly overhead (noon). Note that it is no longer sufficient to assume that this point is on the Equator\r\nGrid lines\r\nI can think of several ways in which #1 can be satisfied: a rotating sphere with a movable viewpoint, two circular hemispherical projections, an unrolled cylindrical projection, or a straightforward unprojected (rectangular) whole-world view. You can choose any of these or come up with your own. See the map projection website for a nice set of pages on map projections. Here is some Java code and documentation from a previous student that may help you.\r\n\r\nIn addition to the three aspects listed above, you should also dynamically update, either graphically or textually, the following information.\r\n\r\n* Simulated date and time\r\n* Orbital position\r\n* Rotational position\r\n* Also, the Physical Factors, Simulation Settings, Invocation Parameters (described below) and Controls should be visible for review.\r\n\r\n### Query Interface\r\n\r\nA user may interact with the system by making a query asking for the temperatures at certain specified locations (which might be the entire planet) during specified time periods. If the data is available to the system, that is, if it has been previously computed, it should be retrieved. If not, a simulation should be conducted to produce it.\r\n\r\nA user query may include the following information; the syntax of a query and how the user enters it, is up to the designer, as is the formatting of the results.\r\n\r\n* Name of the simulation (possibly selecting from those available).\r\n* A specification of the Physical Factors used to compute the data. When searching for existing data, these factors must match exactly.\r\n* Dates and times to be reported on, expressed as a contiguous range. That is, the user can specify a single starting date and time and a single stopping date and time. If a query matches the Physical Factors and locations but describe a time range that extends later than the saved data, there is no requirement to extrapolate from the saved data. Instead a simulation should be run just as if no saved data existed. Otherwise, the system must interpolate temperature values for all times not stored from a previous simulation.\r\n* Locations to be reported on, in terms of contiguous latitude and longitude ranges. That is, the user can specify a single region bounded by two latitude lines and two longitude lines. (Note, that on a sphere, such a quadruple of inputs specifies two, complementary, regions. You should disambiguate the intent by considering the four values to be ordered. That is, the region to be reported on proceeds from the first line to the second in both dimensions.) If the stored data does not exactly match the query, the system must perform an interpolation. (Note that because the planet is spherical, the value of temperature at any point can always be interpolated.) The default geographical range is the whole planet.\r\n**Note** that there may be more than one saved simulation that matches the specified Physical Factors. In this case, the system should select the best available. (See Design Rational subsection below.)\r\nIn addition to specifying these inputs, the user can request any combination of the following outputs.\r\n\r\n* Minimum temperature in the region, when and where it occurred\r\n* Maximum temperature in the region, when and where it occurred\r\n* Mean temperature over the region for the requested times\r\n* Mean temperature over the times for the requested region\r\n* Actual values, whether recorded or interpolated, for the requested cells at the requested times. In this case, temperature values for all grid cells in the region should be reported. Moreover, values for all computed time steps should be reported.\r\nFormat of the resultant values is up to the designer, but should include qualifications concerning its accuracy, both geographic and temporal.\r\n\r\n### Invocation\r\n\r\nThe Heated Planet simulation program should be invoked as follows:\r\n\r\n`java PlanetSim.Demo [-p #] [-g #] [-t #]`\r\nPlanetSim.Demo should be invoked with the following Invocation Parameters to allow the designer to control the persisted results.\r\n\r\n-p #: The precision of the data to be stored, in decimal digits after the decimal point. The default is to use the number of digits storable in a normalized float variable. The maximum is the number of digits storable in a normalized double variable. The minimum is zero.\r\n-g #: The geographic accuracy (sampling rate) of the temperature data to be stored, as an integer percentage of the number of grid cells saved versus the number simulated. The default is 100%; that is, a value is stored for each grid cell.\r\n-t #: The temporal accuracy of the temperature data to be stored, as an integer percentage of the number of time periods saved versus the number computed. The default is 100%; that is, all computed values should be stored.\r\nPersistence\r\n\r\nResults from all simulations should be persistently stored. In addition to the Physical Factors, Simulation Settings, and Invocation Parameters saved for each simulation, the following data should be stored for each grid cell:\r\n\r\n* Latitude: degrees North or South of the Equator\r\n* Longitude: degrees East or West of the Prime Meridian\r\n* Temperature: degrees Kelvin\r\n* Reading date: simulated date at which the temperature reading was taken in terms of years and days since the start of the simulation\r\n* Reading time: hours and minutes since the start of the Reading Date\r\n\r\nThe storage media you use, that is, whether the data is stored in a database, formated document or flat files, is up to you. So also is the data format (XML, text, binary, NetCDF) in which the data is stored.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}